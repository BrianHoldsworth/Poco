//
// Element.cpp
//
// $Id: //poco/1.4/XML/src/Element.cpp#1 $
//
// Library: XML
// Package: DOM
// Module:  DOM
//
// Copyright (c) 2004-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/DOM/Element.h"
#include "Poco/DOM/Document.h"
#include "Poco/DOM/Attr.h"
#include "Poco/DOM/DOMException.h"
#include "Poco/DOM/ElementsByTagNameList.h"
#include "Poco/DOM/Text.h"
#include "Poco/DOM/AttrMap.h"
#include "Poco/NumberParser.h"


namespace Poco {
namespace XML {


Element::Element(Document* pOwnerDocument, const XMLString& namespaceURI, const XMLString& localName, const XMLString& qname):
	AbstractContainerNode(pOwnerDocument),
	_name(pOwnerDocument->namePool().insert(qname, namespaceURI, localName)),
	_pFirstAttr(0)
{
}


Element::Element(Document* pOwnerDocument, const Element& element): 
	AbstractContainerNode(pOwnerDocument, element),
	_name(pOwnerDocument->namePool().insert(element._name)),
	_pFirstAttr(0)
{
	Attr* pAttr = element._pFirstAttr;
	while (pAttr)
	{
		Attr* pClonedAttr = static_cast<Attr*>(pAttr->copyNode(false, pOwnerDocument));
		setAttributeNode(pClonedAttr);
		pClonedAttr->release();
		pAttr = static_cast<Attr*>(pAttr->_pNext);
	}
}


Element::~Element()
{
	if (_pFirstAttr) _pFirstAttr->release();
}


const XMLString& Element::getAttribute(const XMLString& name) const
{
	Attr* pAttr = getAttributeNode(name);
	if (pAttr)
		return pAttr->getValue();
	else
		return EMPTY_STRING;
}


void Element::setAttribute(const XMLString& name, const XMLString& value)
{
	Attr* pAttr = getAttributeNode(name);
	if (pAttr)
	{
		pAttr->setValue(value);
	}
	else
	{
		pAttr = ownerDocument()->createAttribute(name);
		pAttr->setValue(value);
		setAttributeNode(pAttr);
		pAttr->release();
	}
}


void Element::removeAttribute(const XMLString& name)
{
	Attr* pAttr = getAttributeNode(name);
	if (pAttr) removeAttributeNode(pAttr);
}


Attr* Element::getAttributeNode(const XMLString& name) const
{
	Attr* pAttr = _pFirstAttr;
	while (pAttr && pAttr->_name.qname() != name) pAttr = static_cast<Attr*>(pAttr->_pNext);
	return pAttr;
}


Attr* Element::setAttributeNode(Attr* newAttr)
{
	poco_check_ptr (newAttr);

	if (newAttr->ownerDocument() != ownerDocument())
		throw DOMException(DOMException::WRONG_DOCUMENT_ERR);
	if (newAttr->ownerElement())
		throw DOMException(DOMException::INUSE_ATTRIBUTE_ERR);

	Attr* oldAttr = getAttributeNode(newAttr->name());
	if (oldAttr) removeAttributeNode(oldAttr);

	Attr* pCur = _pFirstAttr;
	if (pCur)
	{
		while (pCur->_pNext) pCur = static_cast<Attr*>(pCur->_pNext);
		pCur->_pNext = newAttr;
	}
	else _pFirstAttr = newAttr;
	newAttr->duplicate();
	newAttr->_pParent = this;
	if (_pOwner->events())
		dispatchAttrModified(newAttr, MutationEvent::ADDITION, EMPTY_STRING, newAttr->getValue());

	return oldAttr;
}


Attr* Element::removeAttributeNode(Attr* oldAttr)
{
	poco_check_ptr (oldAttr);

	if (_pOwner->events()) 
		dispatchAttrModified(oldAttr, MutationEvent::REMOVAL, oldAttr->getValue(), EMPTY_STRING);

	if (oldAttr != _pFirstAttr)
	{
		Attr* pCur = _pFirstAttr;
		while (pCur->_pNext != oldAttr) pCur = static_cast<Attr*>(pCur->_pNext);
		if (pCur)
		{
			pCur->_pNext = static_cast<Attr*>(pCur->_pNext->_pNext);
		}
		else throw DOMException(DOMException::NOT_FOUND_ERR);
	}
	else _pFirstAttr = static_cast<Attr*>(_pFirstAttr->_pNext);
	oldAttr->_pNext   = 0;
	oldAttr->_pParent = 0;
	oldAttr->autoRelease();

	return oldAttr;
}


Attr* Element::addAttributeNodeNP(Attr* oldAttr, Attr* newAttr)
{
	newAttr->_pParent = this;
	if (oldAttr)
	{
		oldAttr->_pNext = newAttr;
	}
	else if (_pFirstAttr)
	{
		newAttr->_pNext = _pFirstAttr;
		_pFirstAttr = newAttr;
	}
	else
	{
		_pFirstAttr = newAttr;
	}
	newAttr->duplicate();
	return newAttr;
}


NodeList* Element::getElementsByTagName(const XMLString& name) const
{
	return new ElementsByTagNameList(this, name);
}


NodeList* Element::getElementsByTagNameNS(const XMLString& namespaceURI, const XMLString& localName) const
{
	return new ElementsByTagNameListNS(this, namespaceURI, localName);
}


void Element::normalize()
{
	Node* pCur = firstChild();
	while (pCur)
	{
		if (pCur->nodeType() == Node::ELEMENT_NODE)
		{
			pCur->normalize();
		}
		else if (pCur->nodeType() == Node::TEXT_NODE)
		{
			Node* pNext = pCur->nextSibling();
			while (pNext && pNext->nodeType() == Node::TEXT_NODE)
			{
				static_cast<Text*>(pCur)->appendData(pNext->nodeValue());
				removeChild(pNext);
				pNext = pCur->nextSibling();
			}
		}
		pCur = pCur->nextSibling();
	}
}


const XMLString& Element::nodeName() const
{
	return tagName();
}


NamedNodeMap* Element::attributes() const
{
	return new AttrMap(const_cast<Element*>(this));
}


unsigned short Element::nodeType() const
{
	return Node::ELEMENT_NODE;
}


const XMLString& Element::getAttributeNS(const XMLString& namespaceURI, const XMLString& localName) const
{
	Attr* pAttr = getAttributeNodeNS(namespaceURI, localName);
	if (pAttr)
		return pAttr->getValue();
	else
		return EMPTY_STRING;
}


void Element::setAttributeNS(const XMLString& namespaceURI, const XMLString& qualifiedName, const XMLString& value)
{
	Attr* pAttr = getAttributeNodeNS(namespaceURI, qualifiedName);
	if (pAttr)
	{
		pAttr->setValue(value);
	}
	else
	{
		pAttr = _pOwner->createAttributeNS(namespaceURI, qualifiedName);
		pAttr->setValue(value);
		setAttributeNodeNS(pAttr);
		pAttr->release();
	}
}


void Element::removeAttributeNS(const XMLString& namespaceURI, const XMLString& localName)
{
	Attr* pAttr = getAttributeNodeNS(namespaceURI, localName);
	if (pAttr) removeAttributeNode(pAttr);
}


Attr* Element::getAttributeNodeNS(const XMLString& namespaceURI, const XMLString& localName) const
{
	Attr* pAttr = _pFirstAttr;
	while (pAttr && (pAttr->_name.namespaceURI() != namespaceURI || pAttr->_name.localName() != localName)) pAttr = static_cast<Attr*>(pAttr->_pNext);
	return pAttr;
}


Attr* Element::setAttributeNodeNS(Attr* newAttr)
{
	poco_check_ptr (newAttr);

	if (newAttr->ownerDocument() != ownerDocument())
		throw DOMException(DOMException::WRONG_DOCUMENT_ERR);
	if (newAttr->ownerElement())
		throw DOMException(DOMException::INUSE_ATTRIBUTE_ERR);

	Attr* oldAttr = getAttributeNodeNS(newAttr->namespaceURI(), newAttr->localName());
	if (oldAttr) removeAttributeNode(oldAttr);

	Attr* pCur = _pFirstAttr;
	if (pCur)
	{
		while (pCur->_pNext) pCur = static_cast<Attr*>(pCur->_pNext);
		pCur->_pNext = newAttr;
	}
	else _pFirstAttr = newAttr;
	newAttr->_pParent = this;
	newAttr->duplicate();
	if (_pOwner->events())
		dispatchAttrModified(newAttr, MutationEvent::ADDITION, EMPTY_STRING, newAttr->getValue());

	return oldAttr;
}


bool Element::hasAttribute(const XMLString& name) const
{
	return getAttributeNode(name) != 0;
}


bool Element::hasAttributeNS(const XMLString& namespaceURI, const XMLString& localName) const
{
	return getAttributeNodeNS(namespaceURI, localName) != 0;
}


const XMLString& Element::namespaceURI() const
{
	return _name.namespaceURI();
}


XMLString Element::prefix() const
{
	return _name.prefix();
}


const XMLString& Element::localName() const
{
	return _name.localName();
}


bool Element::hasAttributes() const
{
	return _pFirstAttr != 0;
}


XMLString Element::innerText() const
{
	XMLString result;
	Node* pChild = firstChild();
	while (pChild)
	{
		result.append(pChild->innerText());
		pChild = pChild->nextSibling();
	}
	return result;
}


Element* Element::getChildElement(const XMLString& name) const
{
	Node* pNode = firstChild();
	while (pNode && !(pNode->nodeType() == Node::ELEMENT_NODE && pNode->nodeName() == name))
		pNode = pNode->nextSibling();
	return static_cast<Element*>(pNode);
}


Element* Element::getChildElementNS(const XMLString& namespaceURI, const XMLString& localName) const
{
	Node* pNode = firstChild();
	while (pNode && !(pNode->nodeType() == Node::ELEMENT_NODE && pNode->namespaceURI() == namespaceURI && pNode->localName() == localName))
		pNode = pNode->nextSibling();
	return static_cast<Element*>(pNode);
}


void Element::dispatchNodeRemovedFromDocument()
{
	AbstractContainerNode::dispatchNodeRemovedFromDocument();
	Attr* pAttr = _pFirstAttr;
	while (pAttr)
	{
		pAttr->dispatchNodeRemovedFromDocument();
		pAttr = static_cast<Attr*>(pAttr->_pNext);
	}
}


void Element::dispatchNodeInsertedIntoDocument()
{
	AbstractContainerNode::dispatchNodeInsertedIntoDocument();
	Attr* pAttr = _pFirstAttr;
	while (pAttr)
	{
		pAttr->dispatchNodeInsertedIntoDocument();
		pAttr = static_cast<Attr*>(pAttr->_pNext);
	}
}


Node* Element::copyNode(bool deep, Document* pOwnerDocument) const
{
	Element* pClone = new Element(pOwnerDocument, *this);
	if (deep)
	{
		Node* pNode = firstChild();
		while (pNode)
		{
			pClone->appendChild(static_cast<AbstractNode*>(pNode)->copyNode(true, pOwnerDocument))->release();
			pNode = pNode->nextSibling();
		}
	}
	return pClone;
}


Element* Element::getElementById(const XMLString& elementId, const XMLString& idAttribute) const
{
	if (getAttribute(idAttribute) == elementId)
		return const_cast<Element*>(this);

	Node* pNode = firstChild();
	while (pNode)
	{
		if (pNode->nodeType() == Node::ELEMENT_NODE)
		{
			Element* pResult = static_cast<Element*>(pNode)->getElementById(elementId, idAttribute);
			if (pResult) return pResult;
		}
		pNode = pNode->nextSibling();
	}
	return 0;
}


Element* Element::getElementByIdNS(const XMLString& elementId, const XMLString& idAttributeURI, const XMLString& idAttributeLocalName) const
{
	if (getAttributeNS(idAttributeURI, idAttributeLocalName) == elementId)
		return const_cast<Element*>(this);

	Node* pNode = firstChild();
	while (pNode)
	{
		if (pNode->nodeType() == Node::ELEMENT_NODE)
		{
			Element* pResult = static_cast<Element*>(pNode)->getElementByIdNS(elementId, idAttributeURI, idAttributeLocalName);
			if (pResult) return pResult;
		}
		pNode = pNode->nextSibling();
	}
	return 0;
}


Node* Element::getNodeByPath(const XMLString& path)
{
	XMLString::const_iterator it = path.begin();
	if (it != path.end() && *it == '/') ++it;
	return findNode(it, path.end(), this, 0);
}


Node* Element::getNodeByPathNS(const XMLString& path, const NSMap& nsMap)
{
	XMLString::const_iterator it = path.begin();
	if (it != path.end() && *it == '/') ++it;
	return findNode(it, path.end(), this, &nsMap);
}


Node* Element::findNode(XMLString::const_iterator& it, const XMLString::const_iterator& end, Node* pNode, const NSMap* pNSMap)
{
	if (pNode && it != end)
	{
		if (*it == '[')
		{
			++it;
			if (it != end && *it == '@')
			{
				++it;
				XMLString attr;
				while (it != end && *it != ']' && *it != '=') attr += *it++;
				if (it != end && *it == '=')
				{
					++it;
					XMLString value;
					if (it != end && *it == '\'')
					{
						++it;
						while (it != end && *it != '\'') value += *it++;
						if (it != end) ++it;
					}
					else
					{
						while (it != end && *it != ']') value += *it++;
					}
					if (it != end) ++it;
					return findNode(it, end, findElement(attr, value, pNode, pNSMap), pNSMap);
				}
				else
				{
					if (it != end) ++it;
					return findAttribute(attr, pNode, pNSMap);
				}
			}
			else
			{
				XMLString index;
				while (it != end && *it != ']') index += *it++;
				if (it != end) ++it;
				return findNode(it, end, findElement(Poco::NumberParser::parse(index), pNode, pNSMap), pNSMap);
			}
		}
		else
		{
			while (it != end && *it == '/') ++it;
			XMLString key;
			while (it != end && *it != '/' && *it != '[') key += *it++;
			return findNode(it, end, findElement(key, pNode, pNSMap), pNSMap);
		}
	}
	else return pNode;
}


Node* Element::findElement(const XMLString& name, Node* pNode, const NSMap* pNSMap)
{
	Node* pChild = pNode->firstChild();
	while (pChild)
	{
		if (pChild->nodeType() == Node::ELEMENT_NODE && namesAreEqual(pChild, name, pNSMap))
			return pChild;
		pChild = pChild->nextSibling();
	}
	return 0;
}


Node* Element::findElement(int index, Node* pNode, const NSMap* pNSMap)
{
	Node* pRefNode = pNode;
	if (index > 0)
	{
		pNode = pNode->nextSibling();
		while (pNode)
		{
			if (namesAreEqual(pNode, pRefNode, pNSMap))
			{
				if (--index == 0) break;
			}
			pNode = pNode->nextSibling();
		}
	}
	return pNode;
}


Node* Element::findElement(const XMLString& attr, const XMLString& value, Node* pNode, const NSMap* pNSMap)
{
	Node* pRefNode = pNode;
	Element* pElem = dynamic_cast<Element*>(pNode);
	if (!(pElem && pElem->hasAttributeValue(attr, value, pNSMap)))
	{
		pNode = pNode->nextSibling();
		while (pNode)
		{
			if (namesAreEqual(pNode, pRefNode, pNSMap))
			{
				pElem = dynamic_cast<Element*>(pNode);
				if (pElem && pElem->hasAttributeValue(attr, value, pNSMap)) break;
			}
			pNode = pNode->nextSibling();
		}
	}
	return pNode;
}


Attr* Element::findAttribute(const XMLString& name, Node* pNode, const NSMap* pNSMap)
{
	Attr* pResult(0);
	Element* pElem = dynamic_cast<Element*>(pNode);
	if (pElem)
	{
		if (pNSMap)
		{
			XMLString namespaceURI;
			XMLString localName;
			if (pNSMap->processName(name, namespaceURI, localName, true))
			{
				pResult = pElem->getAttributeNodeNS(namespaceURI, localName);
			}
		}
		else
		{
			pResult = pElem->getAttributeNode(name);
		}
	}
	return pResult;
}


bool Element::hasAttributeValue(const XMLString& name, const XMLString& value, const NSMap* pNSMap)
{
	Attr* pAttr = findAttribute(name, this, pNSMap);
	return pAttr && pAttr->getValue() == value;
}


bool Element::namesAreEqual(Node* pNode1, Node* pNode2, const NSMap* pNSMap)
{
	if (pNSMap)
	{
		return pNode1->localName() == pNode2->localName() && pNode1->namespaceURI() == pNode2->namespaceURI();
	}
	else
	{
		return pNode1->nodeName() == pNode2->nodeName();
	}
}


bool Element::namesAreEqual(Node* pNode, const XMLString& name, const NSMap* pNSMap)
{
	if (pNSMap)
	{
		XMLString namespaceURI;
		XMLString localName;
		if (pNSMap->processName(name, namespaceURI, localName, false))
		{
			return pNode->namespaceURI() == namespaceURI && pNode->localName() == localName;
		}
		else return false;
	}
	else
	{
		return pNode->nodeName() == name;
	}
}


} } // namespace Poco::XML
